## 多线程
### 什么是进程? 什么是线程?
    进程是一个应用程序
    线程是一个进程中的执行场景/执行单元
    一个进程可以有多个线程
### 以java举例
    对于java程序来说, 当在dos命令窗口中输入: java Helloworld 回车之后
    会先启动JVM, 而JVM就是一个进程. JVM再启动一个主线程调用main方法.
    同时再启动一个来讲回收线程负责看护, 回收垃圾. 最起码, 现在的java程序
    至少有这两个线程并发
### 进程和进程是什么关系
    阿里巴巴: 进程
        马云和其它员工是线程
    京东: 进程
        强东和兄弟是线程
    注意:
        进程A和进程B的内存独立不共享(阿里巴巴和京东独立,资源不共享)
    线程A和线程B呢?
    在java语言中:
        线程A和线程B, 堆内存和方法区内存共享
        但是栈内存独立, 一个线程一个栈.
        假设启动10个线程, 会有10个栈空间, 每个栈和每个栈之间,互不干扰,各自执行各自的,
        这是多线程并发.(如火车站和各售票窗口关系)
    之所以有多线程机制, 目的是为了提高程序的处理效率
    
### 使用了多线程后, main方法结束, 是不是有可能程序也不会结束.
    因为main方法结束只是主线程结束, 主栈空了, 其它的栈(线程)可能还在压栈弹栈,
### 分析一个问题: 对于单核cpu来说, 真的可以做到真正的多线程并发么?
    什么是真正的多线程并发?
        t1线程执行t2的.
        t2线程执行t1的.
        t1不会影响t2, t2也不会影响t1. 这叫做多线程并发
    对于多核的cpu电脑来说, 真正的多线程并发是没问题的
        4核CPU表示同一个时间点上, 可以真正的有4个进程并发执行
    对于单核的cpu电脑来说
        不能真正的做到多线程并发, 但是可以做到给人一种"多线程并发"的感觉
    如动画片一般, 当一个个画面切换达到一定速度, 人眼会产生错觉, 感觉是动画的,
    同样对于单核的CPU来说, 同一个时间点上只能处理一个事情, 但是由于CPU处理速度极快,
    多个线程之间频繁切换执行, 给人的感觉就是: 多个事情同时在做.
### 两种创建线程的方式, 用哪种呢?
    Thread.ThreadTest02.java创建线程的方式比较灵活, 因为一个类实现了接口, 还能继承其它的类.
###  关于单核CPU线程对象的生命周期
    新建状态, 就绪状态, 运行状态, 死亡状态, 阻塞状态
### 常见的线程调度模型有哪些?
    抢占式调度模型:
        哪个线程的优先级高, 抢到的CPU时间片的概率就高一些/多一些.
        java采用的就是抢占式调度模型
    均分式调度模型:
        平均分配CPU时间片, 每个线程占有的CPU时间片长度一样,平均分配,一切平等.
        一些编程语言使用
### java中哪些方法是和线程调度
    实例方法:
        void setPriority(int newPriority) 设置线程的优先级
        int getPriority() 获取线程优先级
        最低优先级 1
        默认优先级 5
        最高优先级 10
        优先级比较高的获取CPU时间片可能会多一些(但也不完全是,大概率是多的)

        
    静态方法:
        static void yield() 让位方法
        暂停当前正在执行的线程对象, 并执行其它线程
        yield()方法不是阻塞方法. 让当前线程让位, 让给其它线程使用.
        yield()方法的执行会让当前线程从"运行状态"回到"就绪状态"
        **注意: 在回到就绪状态后,还有机会抢到**

    实例方法:
        void join() 合并线程
```java
class MyThread1 extends Thread{
    public void doSome(){
        MyThread2 t = new MyThread2();
            t.join(); //当前线程进入阻塞, t线程执行, 直到t线程结束. 当前线程才可以继续执行
        }
    }
class MyThread2 extends Thread{}
```
        
## 关于多线程并发环境下, 数据的安全问题
    以后在开发中, 我们的项目都是运行在服务器上. 而服务器已经将线程的定义, 线程对象的创建,
    线程的启动等, 都已经实现完了. 这些代码不需要我们写.
    最重要的是: 你要知道, 你编写的程序需要放到一个多线程环境下运行, 你更需要关注的是这些数据
    在多线程环境下是否是安全的.
    
### 什么时候在多线程并发环境下, 会出现数据的安全问题呢
    三个条件:
        1: 多线程并发
        2: 有共享数据
        3: 共享数据有修改行为
        满足三个条件就会出现线程安全问题
### 怎么解决呢
    线程排队执行, 不能并发(线程同步机制)
    会牺牲一部分效率

### 说到线程同步这块, 涉及到两个专业术语
    异步编程模型:
        线程t1和线程t2, 各自执行各自的, t1不管t2, t2不管t1,
        谁也不需要等谁, 亦称为多线程并发(效率较高)
        **异步就是并发**
    同步编程模型:
        线程t1和线程t2, 在线程t1执行的时候, 必须等待t2执行完毕,
        在线程t2执行的时候, 必须等待t1执行完毕, 两个线程之间发生了
        等待关系, 这就是同步编程模型. 效率较低, 编程排队执行
        **同步就是排队**
## Java中有三大变量[重要]
    实例变量(堆)
    静态变量(方法区)
    局部变量(栈)
    以上三大变量, 局部变量永远都不存在线程安全问题, 因为局部变量不共享, 
    局部变量在栈中, 一个线程一个栈.
    实例变量在堆中, 堆只有一个
    静态变量在方法区, 方法区只有一个
    常量也不会有线程安全问题, 因为不可更改
### 如果使用局部变量的话,
    建议使用StringBuilder, 因为局部变量不存在线程安全问题.
    选择StringBuilder效率比较低
    
    ArrayList是非线程安全的
    Vactor是线程安全的
    HashMap HashSet是非线程安全的
    Hashtable是线程安全的

### 总结:
    synchronized有两种写法
    * 同步代码块
    * 在实例方法上使用synchronized
    * 在静态方法上使用synchronized, 表示找类锁, 
    类锁永远只有一把, 就算创建100个对象,也只有1把类锁.
    对象锁:一个对象一把锁, 100个对象100把锁

### 开发中应该怎么解决线程安全问题?
    是一上来就选择线程同步吗,
    不是,synchronized会让程序的执行效率降低, 用户体验不好, 系统的用户吞吐量(并发量)降低,
    用户体验差, 在不得已情况下再选择线程同步机制
    第一种方案: 尽量使用局部变量代替"实例变量和静态变量"
    第二种方案: 如果必须使用实例变量, 那么可以考虑创建多个对象, 这样实例变量的内存就不共享了.
    (一个线程对应一个对象, 100个线程对应100个对象, 对象不共享, 就没有数据安全问题了)
    第三种方案: 如果不能使用局部变量, 对象也不能创建多个, 这个时候只能选择synchronized了,
    线程同步机制.

## java语言中的线程分为两大类
    一类是: 用户线程
    二类是: 守护线程(后台线程)
    其中最具代表性的是: 垃圾回收线程(守护线程)
    守护线程的特点:
        一般守护线程是一个死循环, 所有的用户线程只要结束,
        守护线程自动结束.
    注意: 主线程main方法是一个用户线程.
    守护线程用在什么地方?
        每天零点的时候系统数据自动备份.
        这个需要使用到定时器, 并且我们可以将定时器设置为守护线程
        一直在那看着, 每到零点的时候备份一次, 所有的用户线程结束的时候,
        守护线程自动退出, 没有必要进行数据备份了
## 定时器
    间隔特定的时间, 执行特定的程序
    每周要进行银行账号总账的操作,
    每天要进行数据的备份操作.

    在实际的开发中, 每隔多久执行一段特定的程序, 这种需求很常见.
    java中可以采取多种方式实现:
        可以使用sleep,设置睡眠时间, 每到这个时间点醒来, 这是最原始的计时器
        java类库中已经写好了一个定时器:java.util.Timer, 可以直接拿来使用
        不过这种也很少用,
        因为实际的开发中, 使用框架的计时器, 目前使用较多的是Spring框架的SpringTask框架.

## 实现线程的第三种方式: 实现Callable接口
    这种方式实现的线程可以获取线程的返回值.
    之前那两种方式是无法获取线程返回值的, 因为run方法返回void.
    思考:
        系统委派一个线程去执行一个任务, 该线程执行完任务之后, 可能会有一个执行结果, 
        怎么才能拿到这个执行结果呢?
        使用Callable接口
## 关于Objet类中的wait和notify方法(生产者和消费者模式)
    第一: wait和notify方法不是线程对象的方法, 是java中任何一个java对象都有的方法, 因为
    这两个方法是Object类中自带的.
    第二: wait()作用
        Object o = new Object();
        o.wait();
        表示:
            让正在o对象上活动的线程进入等待状态, 无期限等待,
            直到被唤醒为止
    第三: notify()作用
        o.notify();
        表示:
            让唤醒o对象上正在等待的线程
        o.notifyAll();
            唤醒所有的线程